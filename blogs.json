{"status":"ok","feed":{"url":"https://medium.com/feed/@viswanathbodapati.career","title":"Stories by Viswanath Bodapati  on Medium","link":"https://medium.com/@viswanathbodapati.career?source=rss-23489b799d67------2","author":"","description":"Stories by Viswanath Bodapati  on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/0*j1rD-w5d1TCeyQ_A"},"items":[{"title":"Daily Coding Problem: Problem #6 [Hard(20/9/22)]","pubDate":"2022-10-14 13:30:39","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-6-hard-20-9-22-a7bf06413a82?source=rss-23489b799d67------2","guid":"https://medium.com/p/a7bf06413a82","author":"Viswanath Bodapati","thumbnail":"https://cdn-images-1.medium.com/max/980/1*6K6aZnB9sebBj3iHHGNL_A.png","description":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Google.</p>\n<p>An XOR linked list is a more memory efficient doubly linked list. Instead of each node holding next and prev fields, it holds a field named both, which is an XOR of the next node and the previous node. Implement an XOR linked list; it has an add(element) which adds the element to the end, and a get(index) which returns the node at\u00a0index.</p>\n<p>If using a language that has no pointers (such as Python), you can assume you have access to get_pointer and dereference_pointer functions that converts between nodes and memory addresses.</p>\n<p>Solution In Python\u00a03.8</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/980/1*6K6aZnB9sebBj3iHHGNL_A.png\"><figcaption>CODE SNIPPET\u00a01</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/690/1*iNKh-ROTSJ9xaoA-IhYIig.png\"><figcaption>CODE SNIPPET\u00a02</figcaption></figure><p>#Daily Coding Problem\u200a\u2014\u200a6</p>\n<p>class Node:<br> def __init__(self, val):<br> self.val = val<br> self.both =\u00a00</p>\n<p>def __str__(self):<br> return str(self.val)</p>\n<p>class XORLinkedList:<br> def __init__(self):<br> self.head = Node(None)<br> self.tail = Node(None)</p>\n<p>def add(element):<br> newNode = Node(element)<br> if self.head.val == None:<br> self.head = self.tail = newNode<br> else:<br> newNode.both = get_pointer(self.tail)<br> self.tail.both = self.tail.both ^ get_pointer(newNode)<br> self.tail =\u00a0newNode</p>\n<p>def get(ind):<br> previousAddr = 0<br> current = this.head<br> for i in range(0,ind-1):<br> temp = get_pointer(current)<br> current = dereference_pointer(previousAddr^current.both)<br> previousAddr = temp<br> if curret.both == previousAddr and i &lt; ind-2:<br> print(\u201cInvalid index.\u201d)<br> return None<br> return\u00a0current</p>\n<p>if __name__ == \u201c__main__\u201d:<br> xorLinkedList = XORLinkedList()</p>\n<p>while True:<br> choice = int(input(\u201c1. ADD\\n2. GET\\n3. EXIT\u201d).strip())<br> if choice == 1:<br> element = int(input(\u201cEnter the element: \u201c).strip())<br> xorLinkedList.add(element)<br> elif choice == 2:<br> ind = int(input(\u201cEnter the index: \u201c).strip())<br> node = xorLinkedList.get(ind)<br> if node\u00a0!= None:<br> print(node)<br> elif choice == 3:<br> exit(0)<br> else:<br> print(\u201cInvalid choice.\u201d)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1018/1*ZiZIlhskblpg5WBF8oqSWw.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 9.36 MB<br>Runtime: 44.374 ms<br>Time Complexity: O(1)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a7bf06413a82\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Google.</p>\n<p>An XOR linked list is a more memory efficient doubly linked list. Instead of each node holding next and prev fields, it holds a field named both, which is an XOR of the next node and the previous node. Implement an XOR linked list; it has an add(element) which adds the element to the end, and a get(index) which returns the node at\u00a0index.</p>\n<p>If using a language that has no pointers (such as Python), you can assume you have access to get_pointer and dereference_pointer functions that converts between nodes and memory addresses.</p>\n<p>Solution In Python\u00a03.8</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/980/1*6K6aZnB9sebBj3iHHGNL_A.png\"><figcaption>CODE SNIPPET\u00a01</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/690/1*iNKh-ROTSJ9xaoA-IhYIig.png\"><figcaption>CODE SNIPPET\u00a02</figcaption></figure><p>#Daily Coding Problem\u200a\u2014\u200a6</p>\n<p>class Node:<br> def __init__(self, val):<br> self.val = val<br> self.both =\u00a00</p>\n<p>def __str__(self):<br> return str(self.val)</p>\n<p>class XORLinkedList:<br> def __init__(self):<br> self.head = Node(None)<br> self.tail = Node(None)</p>\n<p>def add(element):<br> newNode = Node(element)<br> if self.head.val == None:<br> self.head = self.tail = newNode<br> else:<br> newNode.both = get_pointer(self.tail)<br> self.tail.both = self.tail.both ^ get_pointer(newNode)<br> self.tail =\u00a0newNode</p>\n<p>def get(ind):<br> previousAddr = 0<br> current = this.head<br> for i in range(0,ind-1):<br> temp = get_pointer(current)<br> current = dereference_pointer(previousAddr^current.both)<br> previousAddr = temp<br> if curret.both == previousAddr and i &lt; ind-2:<br> print(\u201cInvalid index.\u201d)<br> return None<br> return\u00a0current</p>\n<p>if __name__ == \u201c__main__\u201d:<br> xorLinkedList = XORLinkedList()</p>\n<p>while True:<br> choice = int(input(\u201c1. ADD\\n2. GET\\n3. EXIT\u201d).strip())<br> if choice == 1:<br> element = int(input(\u201cEnter the element: \u201c).strip())<br> xorLinkedList.add(element)<br> elif choice == 2:<br> ind = int(input(\u201cEnter the index: \u201c).strip())<br> node = xorLinkedList.get(ind)<br> if node\u00a0!= None:<br> print(node)<br> elif choice == 3:<br> exit(0)<br> else:<br> print(\u201cInvalid choice.\u201d)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1018/1*ZiZIlhskblpg5WBF8oqSWw.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 9.36 MB<br>Runtime: 44.374 ms<br>Time Complexity: O(1)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a7bf06413a82\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["daily-blog","data-structures","daily-coding-problem","algorithms","daily-coding"]},{"title":"Daily Coding Problem: Problem #5 [Medium(19/9/22)]","pubDate":"2022-10-08 06:43:10","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-5-medium-19-9-22-873ccd41909f?source=rss-23489b799d67------2","guid":"https://medium.com/p/873ccd41909f","author":"Viswanath Bodapati","thumbnail":"https://cdn-images-1.medium.com/max/460/1*8w_P7_Yok6qZNnQMhob-0w.png","description":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by Jane\u00a0Street.</p>\n<p>cons(a, b) constructs a pair, and car(pair) and cdr(pair) returns the first and last element of that pair. For example, car(cons(3, 4)) returns 3, and cdr(cons(3, 4)) returns\u00a04.</p>\n<p>Given this implementation of\u00a0cons:</p>\n<pre>def cons(a, b):<br>    def pair(f):<br>        return f(a, b)<br>    return pair</pre>\n<p>Implement car and\u00a0cdr.</p>\n<p>Solution In Python\u00a03.8</p>\n<p>def cons(a, b):<br>\u2026def pair(f):<br>\u2026..return f(a, b)<br>\u00a0\u2026return\u00a0pair</p>\n<p>def car(f):<br>\u2026def left(a, b):<br>\u2026..return a<br>\u00a0\u2026return\u00a0f(left)</p>\n<p>def cdr(f):<br>\u2026def right(a, b):<br>\u2026. return b<br>...return f(right)</p>\n<p>print(car(cons(10,20)))<br>print(cdr(cons(10,20)))</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/460/1*8w_P7_Yok6qZNnQMhob-0w.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 67 MB<br>Runtime: 99 ms<br>Time Complexity: O(1)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=873ccd41909f\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by Jane\u00a0Street.</p>\n<p>cons(a, b) constructs a pair, and car(pair) and cdr(pair) returns the first and last element of that pair. For example, car(cons(3, 4)) returns 3, and cdr(cons(3, 4)) returns\u00a04.</p>\n<p>Given this implementation of\u00a0cons:</p>\n<pre>def cons(a, b):<br>    def pair(f):<br>        return f(a, b)<br>    return pair</pre>\n<p>Implement car and\u00a0cdr.</p>\n<p>Solution In Python\u00a03.8</p>\n<p>def cons(a, b):<br>\u2026def pair(f):<br>\u2026..return f(a, b)<br>\u00a0\u2026return\u00a0pair</p>\n<p>def car(f):<br>\u2026def left(a, b):<br>\u2026..return a<br>\u00a0\u2026return\u00a0f(left)</p>\n<p>def cdr(f):<br>\u2026def right(a, b):<br>\u2026. return b<br>...return f(right)</p>\n<p>print(car(cons(10,20)))<br>print(cdr(cons(10,20)))</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/460/1*8w_P7_Yok6qZNnQMhob-0w.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 67 MB<br>Runtime: 99 ms<br>Time Complexity: O(1)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=873ccd41909f\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["data-structures","algorithms"]},{"title":"Daily Coding Problem: Problem #4 [Hard(18/9/22)]","pubDate":"2022-10-05 11:34:23","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-4-hard-18-9-22-1bffc222615b?source=rss-23489b799d67------2","guid":"https://medium.com/p/1bffc222615b","author":"Viswanath Bodapati","thumbnail":"https://cdn-images-1.medium.com/max/341/1*4LqmUN24x2v4Ur44PyIM7w.png","description":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Stripe.</p>\n<p>Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as\u00a0well.</p>\n<p>For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give\u00a03.</p>\n<p>You can modify the input array in-place.</p>\n<p>Solution In Python\u00a03.8</p>\n<p>numbers = [int(n) for n in input().split(\u2018,\u2019)]<br>#numbers = [3, 4, -1, 1]<br>numbers.sort()<br>next_number = 1<br>for n in numbers:<br>\u2026.if n &gt; 0:<br>\u2026\u2026..if n &gt; next_number:<br>\u2026\u2026\u2026\u2026break<br>\u2026\u2026..else:<br>\u2026\u2026\u2026\u2026next_number = n + 1<br>print(next_number)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/341/1*4LqmUN24x2v4Ur44PyIM7w.png\"><figcaption>OUTPUT FOR ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 23.9 MB<br>Runtime: 83 ms<br>Time Complexity: O(n)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1bffc222615b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Stripe.</p>\n<p>Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as\u00a0well.</p>\n<p>For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give\u00a03.</p>\n<p>You can modify the input array in-place.</p>\n<p>Solution In Python\u00a03.8</p>\n<p>numbers = [int(n) for n in input().split(\u2018,\u2019)]<br>#numbers = [3, 4, -1, 1]<br>numbers.sort()<br>next_number = 1<br>for n in numbers:<br>\u2026.if n &gt; 0:<br>\u2026\u2026..if n &gt; next_number:<br>\u2026\u2026\u2026\u2026break<br>\u2026\u2026..else:<br>\u2026\u2026\u2026\u2026next_number = n + 1<br>print(next_number)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/341/1*4LqmUN24x2v4Ur44PyIM7w.png\"><figcaption>OUTPUT FOR ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 23.9 MB<br>Runtime: 83 ms<br>Time Complexity: O(n)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1bffc222615b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["daily-coding","daily-coding-problem","algorithms","data-structures"]},{"title":"Daily Coding Problem: Problem #3 [Hard(17/9/22)]","pubDate":"2022-10-04 19:11:16","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-3-hard-17-9-22-20c96b3e4db6?source=rss-23489b799d67------2","guid":"https://medium.com/p/20c96b3e4db6","author":"Viswanath Bodapati","thumbnail":"https://cdn-images-1.medium.com/max/697/1*guS2SUwlfvlGYP7huec6DA.png","description":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Google.</p>\n<p>Given the root to a binary tree, implement serialize(root), which serializes the tree into a string, and deserialize(s), which deserializes the string back into the\u00a0tree.</p>\n<p>For example, given the following Node\u00a0class</p>\n<pre>class Node:<br>    def __init__(self, val, left=None, right=None):<br>        self.val = val<br>        self.left = left<br>        self.right = right</pre>\n<p>The following test should\u00a0pass:</p>\n<pre>node = Node('root', Node('left', Node('left.left')), Node('right'))<br>assert deserialize(serialize(node)).left.left.val == 'left.left'</pre>\n<p>Solution In Python\u00a03.8</p>\n<p>class Node:<br>\u2026.def __init__(self,value, left=None, right=None):<br>\u2026\u2026..self.value = value<br>\u2026\u2026..self.left = left <br>\u2026\u2026..self.right =\u00a0right</p>\n<p>class Sol:<br>\u2026.def Serialize(self, head):<br>\u2026\u2026..def get_elmts(root):<br>.\u2026\u2026\u2026..if root:<br>.\u2026\u2026\u2026\u2026\u2026list1.append(root.value)<br>\u00a0.\u2026\u2026\u2026\u2026\u2026get_elmts(root.left)<br>\u00a0.\u2026\u2026\u2026\u2026\u2026get_elmts(root.right)<br>\u00a0.\u2026\u2026\u2026..else:<br>\u00a0.\u2026\u2026\u2026\u2026\u2026list1.append(\u2018Null\u2019)</p>\n<p>\u2026.list1 = []<br>\u2026.get_elmts(head)<br>\u2026.return\u00a0list1</p>\n<p>\u2026.def deSerialize(Self,data):<br>\u2026\u2026..def build():<br>\u2026\u2026\u2026\u2026i = next(values)<br>\u2026\u2026\u2026\u2026if i == \u201cNull\u201d:<br>\u2026\u2026\u2026\u2026\u2026.return None<br>\u2026\u2026\u2026\u2026root = Node(i)<br>\u2026\u2026\u2026\u2026root.left = build()<br>\u2026\u2026\u2026\u2026root.right = build()<br>\u2026\u2026\u2026\u2026return root</p>\n<p>\u2026.values = iter(data.split())<br>\u2026.return\u00a0build()</p>\n<p>def traverse(root):<br>\u2026.if not root:<br>\u2026\u2026.return None<br>\u2026.print(root.value,end = \u2018 \u2018)<br>\u2026.traverse(root.left)<br>\u00a0\u2026traverse(root.right)</p>\n<p>node = Node(\u2018root\u2019,Node(\u2018left\u2019,Node(\u2018left.left\u2019)),Node(\u2018right\u2019)</p>\n<p>val = Sol().Serialize(node)<br>ans = Sol().deSerialize(\u201c \u201c.join(val))<br>traverse(ans)<br>print(\u2018\\n\u2019,val)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/697/1*guS2SUwlfvlGYP7huec6DA.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 23.9 MB<br>Runtime: 92 ms<br>Time Complexity: O(h)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=20c96b3e4db6\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Good morning! Here\u2019s your coding interview problem for\u00a0today.</p>\n<p>This problem was asked by\u00a0Google.</p>\n<p>Given the root to a binary tree, implement serialize(root), which serializes the tree into a string, and deserialize(s), which deserializes the string back into the\u00a0tree.</p>\n<p>For example, given the following Node\u00a0class</p>\n<pre>class Node:<br>    def __init__(self, val, left=None, right=None):<br>        self.val = val<br>        self.left = left<br>        self.right = right</pre>\n<p>The following test should\u00a0pass:</p>\n<pre>node = Node('root', Node('left', Node('left.left')), Node('right'))<br>assert deserialize(serialize(node)).left.left.val == 'left.left'</pre>\n<p>Solution In Python\u00a03.8</p>\n<p>class Node:<br>\u2026.def __init__(self,value, left=None, right=None):<br>\u2026\u2026..self.value = value<br>\u2026\u2026..self.left = left <br>\u2026\u2026..self.right =\u00a0right</p>\n<p>class Sol:<br>\u2026.def Serialize(self, head):<br>\u2026\u2026..def get_elmts(root):<br>.\u2026\u2026\u2026..if root:<br>.\u2026\u2026\u2026\u2026\u2026list1.append(root.value)<br>\u00a0.\u2026\u2026\u2026\u2026\u2026get_elmts(root.left)<br>\u00a0.\u2026\u2026\u2026\u2026\u2026get_elmts(root.right)<br>\u00a0.\u2026\u2026\u2026..else:<br>\u00a0.\u2026\u2026\u2026\u2026\u2026list1.append(\u2018Null\u2019)</p>\n<p>\u2026.list1 = []<br>\u2026.get_elmts(head)<br>\u2026.return\u00a0list1</p>\n<p>\u2026.def deSerialize(Self,data):<br>\u2026\u2026..def build():<br>\u2026\u2026\u2026\u2026i = next(values)<br>\u2026\u2026\u2026\u2026if i == \u201cNull\u201d:<br>\u2026\u2026\u2026\u2026\u2026.return None<br>\u2026\u2026\u2026\u2026root = Node(i)<br>\u2026\u2026\u2026\u2026root.left = build()<br>\u2026\u2026\u2026\u2026root.right = build()<br>\u2026\u2026\u2026\u2026return root</p>\n<p>\u2026.values = iter(data.split())<br>\u2026.return\u00a0build()</p>\n<p>def traverse(root):<br>\u2026.if not root:<br>\u2026\u2026.return None<br>\u2026.print(root.value,end = \u2018 \u2018)<br>\u2026.traverse(root.left)<br>\u00a0\u2026traverse(root.right)</p>\n<p>node = Node(\u2018root\u2019,Node(\u2018left\u2019,Node(\u2018left.left\u2019)),Node(\u2018right\u2019)</p>\n<p>val = Sol().Serialize(node)<br>ans = Sol().deSerialize(\u201c \u201c.join(val))<br>traverse(ans)<br>print(\u2018\\n\u2019,val)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/697/1*guS2SUwlfvlGYP7huec6DA.png\"><figcaption>OUTPUT FOR THE ABOVE\u00a0CODE</figcaption></figure><p>Memory Usage: 23.9 MB<br>Runtime: 92 ms<br>Time Complexity: O(h)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=20c96b3e4db6\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["data","algorithms","data-structures","binary-tree"]},{"title":"Daily Coding Problem: Problem #2 [Hard(16/9/22)]","pubDate":"2022-09-17 17:39:38","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-2-hard-16-9-22-690fe506bc0e?source=rss-23489b799d67------2","guid":"https://medium.com/p/690fe506bc0e","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=690fe506bc0e","description":"\n<p>This problem was asked by\u00a0Uber.</p>\n<p>Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at\u00a0i.</p>\n<p>For example, if our input was [1, 2, 3, 4, 5], the expected output would be [120, 60, 40, 30, 24]. If our input was [3, 2, 1], the expected output would be [2, 3,\u00a06].</p>\n<p>Follow-up: what if you can\u2019t use division?</p>\n<p>Solution (pyth\u00a03.8):</p>\n<p>def findpros(arr):<br>```ans=[]<br> ```for i in range(len(arr)):<br> ``````k=len(arr)-1<br> ``````p =1 <br> ``````while k&gt;i:<br> `````````p*=arr[k]<br> `````````k-=1<br> ``````j = 0<br> ``````while j&lt;i:<br> `````````p*=arr[j]<br> `````````j+=1 <br><br> ``````ans.append(p)<br> ```return ans</p>\n<p>arr = list(map(int,input().split()))<br>print(findpros(arr))</p>\n<p>This takes Time Complexity of\u00a0O(n\u00b2).</p>\n<p>def findpros(a):<br> ```prod = 1<br> ```flag = 0<br> ```n=len(a)<br> ```for i in range(n):<br>``````if (a[i] == 0):<br> ````````flag += 1<br> ``````else:<br>`````````prod *= a[i]<br> ```arr = [0 for i in range(n)]<br> ```for i in range(n):<br> ``````if (flag &gt; 1):<br> ``````````arr[i] = 0<br> ``````elif (flag == 0):<br> ``````````arr[i] = (prod // a[i])<br> ``````elif (flag == 1 and a[i]\u00a0!= 0):<br> ``````````arr[i] = 0<br> ``````else:<br> ``````````arr[i] = prod<br><br>```return arr<br><br>array = list(map(int,input().split()))<br>ans = findpros(array)</p>\n<p>print(ans)</p>\n<p>This takes Time Complexity of\u00a0O(n).</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=690fe506bc0e\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>This problem was asked by\u00a0Uber.</p>\n<p>Given an array of integers, return a new array such that each element at index i of the new array is the product of all the numbers in the original array except the one at\u00a0i.</p>\n<p>For example, if our input was [1, 2, 3, 4, 5], the expected output would be [120, 60, 40, 30, 24]. If our input was [3, 2, 1], the expected output would be [2, 3,\u00a06].</p>\n<p>Follow-up: what if you can\u2019t use division?</p>\n<p>Solution (pyth\u00a03.8):</p>\n<p>def findpros(arr):<br>```ans=[]<br> ```for i in range(len(arr)):<br> ``````k=len(arr)-1<br> ``````p =1 <br> ``````while k&gt;i:<br> `````````p*=arr[k]<br> `````````k-=1<br> ``````j = 0<br> ``````while j&lt;i:<br> `````````p*=arr[j]<br> `````````j+=1 <br><br> ``````ans.append(p)<br> ```return ans</p>\n<p>arr = list(map(int,input().split()))<br>print(findpros(arr))</p>\n<p>This takes Time Complexity of\u00a0O(n\u00b2).</p>\n<p>def findpros(a):<br> ```prod = 1<br> ```flag = 0<br> ```n=len(a)<br> ```for i in range(n):<br>``````if (a[i] == 0):<br> ````````flag += 1<br> ``````else:<br>`````````prod *= a[i]<br> ```arr = [0 for i in range(n)]<br> ```for i in range(n):<br> ``````if (flag &gt; 1):<br> ``````````arr[i] = 0<br> ``````elif (flag == 0):<br> ``````````arr[i] = (prod // a[i])<br> ``````elif (flag == 1 and a[i]\u00a0!= 0):<br> ``````````arr[i] = 0<br> ``````else:<br> ``````````arr[i] = prod<br><br>```return arr<br><br>array = list(map(int,input().split()))<br>ans = findpros(array)</p>\n<p>print(ans)</p>\n<p>This takes Time Complexity of\u00a0O(n).</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=690fe506bc0e\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["coding","data-science","data-structures","algorithms"]},{"title":"Daily Coding Problem: Problem #1 [Easy(16/09/22)]","pubDate":"2022-09-17 03:11:52","link":"https://medium.com/@viswanathbodapati.career/daily-coding-problem-problem-1-16-09-2022-55162a04718a?source=rss-23489b799d67------2","guid":"https://medium.com/p/55162a04718a","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=55162a04718a","description":"\n<p>Question:</p>\n<p>This problem was recently asked by\u00a0Google.</p>\n<p>Given a list of numbers and a number k, return whether any two numbers from the list add up to\u00a0k.</p>\n<p>For example, given [10, 15, 3, 7] and k of 17, return true since 10 + 7 is\u00a017.</p>\n<p>Bonus: Can you do this in one\u00a0pass?</p>\n<p>Solution [pyth3.8]:</p>\n<p>def find2sum(arr,key):<br> ```for i in range(len(arr)):<br>``````for j in range(i,len(arr)):<br>``````````if a[i]+a[j]==key:<br> `````````````return True</p>\n<p>```return False<br><br>a = list(map(int,input().split()))<br>k = eval(input())</p>\n<p>print(find2sum(a,k))</p>\n<p>This takes the time complexity of\u00a0O(n\u00b2).</p>\n<p>def find2sum(arr,key):<br> ```arr.sort()<br> ```for i,j in zip([k for k in range(len(arr))],[x for x in range(len(arr)-1,-1,-1)]):<br> ``````sumo = arr[i]+arr[j]<br> ``````if sumo&lt;key: <br> `````````i+=1<br> ``````elif sumo&gt;key:<br> `````````j-=1 <br> ``````else:<br> `````````return True</p>\n<p>```return False<br><br>a = list(map(int,input().split()))<br>k = eval(input())</p>\n<p>print(find2sum(a,k))</p>\n<p>This takes the time complexity of\u00a0O(n).</p>\n<p><strong>Proof by induction:</strong> Let a[0,n] be an array of length n+1 and p = (p1, p2) where p1, p2 are integers and p1 &lt;= p2 (w.l.o.g.). Assume a[0,n] contains p1 and p2. In the case that it does not, the algorithm is obviously correct.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=55162a04718a\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>Question:</p>\n<p>This problem was recently asked by\u00a0Google.</p>\n<p>Given a list of numbers and a number k, return whether any two numbers from the list add up to\u00a0k.</p>\n<p>For example, given [10, 15, 3, 7] and k of 17, return true since 10 + 7 is\u00a017.</p>\n<p>Bonus: Can you do this in one\u00a0pass?</p>\n<p>Solution [pyth3.8]:</p>\n<p>def find2sum(arr,key):<br> ```for i in range(len(arr)):<br>``````for j in range(i,len(arr)):<br>``````````if a[i]+a[j]==key:<br> `````````````return True</p>\n<p>```return False<br><br>a = list(map(int,input().split()))<br>k = eval(input())</p>\n<p>print(find2sum(a,k))</p>\n<p>This takes the time complexity of\u00a0O(n\u00b2).</p>\n<p>def find2sum(arr,key):<br> ```arr.sort()<br> ```for i,j in zip([k for k in range(len(arr))],[x for x in range(len(arr)-1,-1,-1)]):<br> ``````sumo = arr[i]+arr[j]<br> ``````if sumo&lt;key: <br> `````````i+=1<br> ``````elif sumo&gt;key:<br> `````````j-=1 <br> ``````else:<br> `````````return True</p>\n<p>```return False<br><br>a = list(map(int,input().split()))<br>k = eval(input())</p>\n<p>print(find2sum(a,k))</p>\n<p>This takes the time complexity of\u00a0O(n).</p>\n<p><strong>Proof by induction:</strong> Let a[0,n] be an array of length n+1 and p = (p1, p2) where p1, p2 are integers and p1 &lt;= p2 (w.l.o.g.). Assume a[0,n] contains p1 and p2. In the case that it does not, the algorithm is obviously correct.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=55162a04718a\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["data-structures","programming","algorithms"]},{"title":"DS ALGORITHM\u2019s\u200a\u2014\u200aMerge Sort O(nlogn)","pubDate":"2022-08-09 08:17:09","link":"https://medium.com/@viswanathbodapati.career/ds-algorithms-merge-sort-o-nlogn-22558fd9b640?source=rss-23489b799d67------2","guid":"https://medium.com/p/22558fd9b640","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=22558fd9b640","description":"\n<h3><strong>DS ALGORITHM\u2019s\u200a\u2014\u200aMerge Sort\u00a0O(nlogn)</strong></h3>\n<p>The algorithm is used to sort the array by dividing the elements of the array until we get a single element and then performing a compare operation on those elements where we compare the elements from 2 arrays, i.e., left and right, to find the min value and insert it into a temporary array. We perform these operations until all the elements of the array are traversed. This approach is known as the \u201cDivide and Conquer\u201d algorithm. We use 2 functions, where one function is a recursive function where it divides the array of elements, and the other function is used to combine the elements. The time complexity in all the 3 cases, i.e., best, average, and worst cases, is O(nlogn).</p>\n<p>static int\u00a0si;</p>\n<p>void merge(int[]\u00a0,int, int, int);<br>void mergeSort(int arr[],int start, int end)<br>{<br> if(start&lt;end)<br> {<br> int mid = (start+end)/2;<br> mergeSort(arr,start,mid);<br> mergeSort(arr,mid+1,end);<br> merge(arr,start,mid,end);<br> }<br>}</p>\n<p>void merge(int arr[], int start, int mid, int end)<br>{<br> int k = start;<br> int i = start,j=mid+1;<br> int temp[si];<br><br> while(j&lt;=end &amp;&amp; i&lt;=mid)<br> {<br> if(arr[i]&lt;arr[j])<br> {<br> temp[k]=arr[i];<br> i++;<br> }<br> else<br> {<br> temp[k]=arr[j];<br> j++;<br> }<br> k++;<br> }<br><br> if(i&gt;mid)<br> {<br> while(j&lt;=end)<br> {<br> temp[k]=arr[j];<br> j++;<br> k++;<br> }<br> }<br> else<br> {<br> while(i&lt;=mid)<br> {<br> temp[k] = arr[i];<br> i++;<br> k++;<br> }<br> }<br><br> int x = start;<br> while(x&lt;k)<br> {<br> arr[x]=temp[x];<br> x++;<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22558fd9b640\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3><strong>DS ALGORITHM\u2019s\u200a\u2014\u200aMerge Sort\u00a0O(nlogn)</strong></h3>\n<p>The algorithm is used to sort the array by dividing the elements of the array until we get a single element and then performing a compare operation on those elements where we compare the elements from 2 arrays, i.e., left and right, to find the min value and insert it into a temporary array. We perform these operations until all the elements of the array are traversed. This approach is known as the \u201cDivide and Conquer\u201d algorithm. We use 2 functions, where one function is a recursive function where it divides the array of elements, and the other function is used to combine the elements. The time complexity in all the 3 cases, i.e., best, average, and worst cases, is O(nlogn).</p>\n<p>static int\u00a0si;</p>\n<p>void merge(int[]\u00a0,int, int, int);<br>void mergeSort(int arr[],int start, int end)<br>{<br> if(start&lt;end)<br> {<br> int mid = (start+end)/2;<br> mergeSort(arr,start,mid);<br> mergeSort(arr,mid+1,end);<br> merge(arr,start,mid,end);<br> }<br>}</p>\n<p>void merge(int arr[], int start, int mid, int end)<br>{<br> int k = start;<br> int i = start,j=mid+1;<br> int temp[si];<br><br> while(j&lt;=end &amp;&amp; i&lt;=mid)<br> {<br> if(arr[i]&lt;arr[j])<br> {<br> temp[k]=arr[i];<br> i++;<br> }<br> else<br> {<br> temp[k]=arr[j];<br> j++;<br> }<br> k++;<br> }<br><br> if(i&gt;mid)<br> {<br> while(j&lt;=end)<br> {<br> temp[k]=arr[j];<br> j++;<br> k++;<br> }<br> }<br> else<br> {<br> while(i&lt;=mid)<br> {<br> temp[k] = arr[i];<br> i++;<br> k++;<br> }<br> }<br><br> int x = start;<br> while(x&lt;k)<br> {<br> arr[x]=temp[x];<br> x++;<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=22558fd9b640\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["problem-solving","algorithms","data-structures","sorting-algorithms"]},{"title":"DS ALGORITHM\u2019s\u200a\u2014\u200aSelection Sort O(n\u00b2)","pubDate":"2022-08-08 17:28:39","link":"https://medium.com/@viswanathbodapati.career/ds-algorithms-selection-sort-o-n%C2%B2-83f249d65ed9?source=rss-23489b799d67------2","guid":"https://medium.com/p/83f249d65ed9","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=83f249d65ed9","description":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aSelection Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by selecting the minimum value\u2019s index and traversing the array elements present after that element and comparing each new element if we find out that the new element is less than the chosen element then we update the minimum value index with the new value\u2019s index. After the Traversal, we swap the array[i] element with array[minimum]. This process is done until I reach the size -1 index. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in all the 3 cases i.e Best, Average, and Worst cases is\u00a0O(n\u00b2).</p>\n<p>Algorithm SelectionSort(int array[], int size)<br>{<br> for(int i = 0;i&lt;size-1;i++)<br> {<br> int minimum = i;<br> for(int j =i+1;j&lt;size;j++)<br> {<br> if(array[minimum]&gt;array[j])<br> {<br> minimum = j;<br> }<br> }<br> swap(array[i],array[minimum]);<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=83f249d65ed9\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aSelection Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by selecting the minimum value\u2019s index and traversing the array elements present after that element and comparing each new element if we find out that the new element is less than the chosen element then we update the minimum value index with the new value\u2019s index. After the Traversal, we swap the array[i] element with array[minimum]. This process is done until I reach the size -1 index. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in all the 3 cases i.e Best, Average, and Worst cases is\u00a0O(n\u00b2).</p>\n<p>Algorithm SelectionSort(int array[], int size)<br>{<br> for(int i = 0;i&lt;size-1;i++)<br> {<br> int minimum = i;<br> for(int j =i+1;j&lt;size;j++)<br> {<br> if(array[minimum]&gt;array[j])<br> {<br> minimum = j;<br> }<br> }<br> swap(array[i],array[minimum]);<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=83f249d65ed9\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["problem-solving","data-structures","algorithms","programming"]},{"title":"DS ALGORITHM\u2019s\u200a\u2014\u200aInsertion Sort O(n\u00b2)","pubDate":"2022-08-03 17:20:54","link":"https://medium.com/@viswanathbodapati.career/ds-algorithms-insertion-sort-o-n%C2%B2-b68eb19b0f5c?source=rss-23489b799d67------2","guid":"https://medium.com/p/b68eb19b0f5c","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b68eb19b0f5c","description":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aInsertion Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by traversing all the previous index elements till it reaches the starting position and all those elements must be less than the key element. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in the Best Case would be O(n) whereas in the average and worst cases it is given as\u00a0O(n\u00b2).</p>\n<p>void insertion_sort(int arr[],int n)<br>{<br> for(int i =1;i&lt;n;i++)<br> { <br> int k = arr[i];<br> int j = i-1;<br> while(j&gt;=0&amp;&amp; k&lt;arr[j])<br> {<br> arr[j+1]=arr[j];<br> j\u200a\u2014\u200a;<br> }<br> arr[j+1]=k;<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b68eb19b0f5c\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aInsertion Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by traversing all the previous index elements till it reaches the starting position and all those elements must be less than the key element. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in the Best Case would be O(n) whereas in the average and worst cases it is given as\u00a0O(n\u00b2).</p>\n<p>void insertion_sort(int arr[],int n)<br>{<br> for(int i =1;i&lt;n;i++)<br> { <br> int k = arr[i];<br> int j = i-1;<br> while(j&gt;=0&amp;&amp; k&lt;arr[j])<br> {<br> arr[j+1]=arr[j];<br> j\u200a\u2014\u200a;<br> }<br> arr[j+1]=k;<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b68eb19b0f5c\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["sorting-algorithms","data-structures","problem-solving","algorithms"]},{"title":"DS ALGORITHM\u2019s\u200a\u2014\u200aBubble Sort O(n\u00b2)","pubDate":"2022-08-03 12:09:21","link":"https://medium.com/@viswanathbodapati.career/ds-algorithms-bubble-sort-o-n%C2%B2-d0fa8a37ad16?source=rss-23489b799d67------2","guid":"https://medium.com/p/d0fa8a37ad16","author":"Viswanath Bodapati","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d0fa8a37ad16","description":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aBubble Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by swapping the two neighboring elements. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in the Best Case would be O(n) whereas in the average and worst cases it is given as O(n\u00b2). The function swap is used to perform the operation to interchange the element position.</p>\n<p>void swap(int *p1, int *p2)<br>{<br> int temp = *p1;<br> *p1 = *p2;<br> *p2 = temp;<br>}</p>\n<p>void bubble_sort(int arr[],int n)<br>{ <br> for(int i = 0; i&lt;n; i++)<br> {<br> for (int j =0; j&lt;n-i; j++)<br> {<br> if(arr[j]&gt;arr[j+1])<br> swap(arr[j],arr[j+1]);<br> }<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d0fa8a37ad16\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>DS ALGORITHM\u2019s\u200a\u2014\u200aBubble Sort\u00a0O(n\u00b2)</h3>\n<p>The algorithm is used to sort the array by swapping the two neighboring elements. The function takes 2 arguments i.e an array of elements to be sorted and the number of elements. The time complexity in the Best Case would be O(n) whereas in the average and worst cases it is given as O(n\u00b2). The function swap is used to perform the operation to interchange the element position.</p>\n<p>void swap(int *p1, int *p2)<br>{<br> int temp = *p1;<br> *p1 = *p2;<br> *p2 = temp;<br>}</p>\n<p>void bubble_sort(int arr[],int n)<br>{ <br> for(int i = 0; i&lt;n; i++)<br> {<br> for (int j =0; j&lt;n-i; j++)<br> {<br> if(arr[j]&gt;arr[j+1])<br> swap(arr[j],arr[j+1]);<br> }<br> }<br>}</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=d0fa8a37ad16\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["data-structures","grind","problem-solving","algorithms"]}]}